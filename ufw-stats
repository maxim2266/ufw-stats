#!/usr/bin/env python3
'''
BSD 3-Clause License

Copyright (c) 2021, Maxim Konakov
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of the copyright holder nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
'''

from sys import exit, stdin, argv
from signal import signal, strsignal, SIGHUP, SIGINT, SIGTERM

# install signal handlers
def sig_handler(sig, _):
	exit(f'{strsignal(sig)} [{sig}]')

signal(SIGHUP, sig_handler)
signal(SIGINT, sig_handler)
signal(SIGTERM, sig_handler)

# we don't use stdin here
stdin.close()

# main imports
from re import compile as regex
from subprocess import PIPE, Popen as popen
from urllib.request import urlopen
from ssl import create_default_context as ssl_default_context
from json import load as read_json, JSONDecodeError
from ipaddress import ip_address, ip_interface, summarize_address_range as ip_range
from socket import gethostbyaddr
from itertools import compress as choose

# little helpers
failed = lambda info: 'ERROR' in info

def set_value(d, key, val):
	if val:
		d[key] = val

# constructor for ip address info function
def ip_info_fetcher(url_prefix = 'https://rdap.arin.net/registry/ip/'):
	ctx = ssl_default_context()	# SSL context

	# prevent the "[SSL: DH_KEY_TOO_SMALL] dh key too small" error
	ctx.set_ciphers('ALL@SECLEVEL=1')	# or 'DEFAULT@SECLEVEL=1'

	def ask_who_is(addr):
		try:
			with urlopen(url_prefix + addr, context = ctx, timeout = 5) as resp:
				s = read_json(resp)
		except JSONDecodeError as err:
			return { 'ERROR': f'invalid JSON response: {err.msg}' }
		except OSError as err:
			return { 'ERROR': str(err).lstrip('<').rstrip('>')  }

		try:
			res = {
				'NAME': s['name'],
				'NET': tuple(ip_range(ip_address(s['startAddress']), ip_address(s['endAddress'])))
			}
		except KeyError as err:
			try:
				return { 'ERROR': f'{str(s["errorCode"])}: {s["title"]}' }
			except KeyError:
				return { 'ERROR': f'parameter "{err}" is missing from JSON response' }

		try:
			res['COUNTRY'] = s['country'].upper()
		except KeyError:
			pass

		try:
			res['DESCR'] = s['remarks'][0]['description'][0]
		except (KeyError, IndexError):
			pass

		return res

	# list of networks
	ip_nets = []	# of (IPNetwork, info)

	def get(addr, info):
		a = addr.compressed

		for n, data in ip_nets:
			if addr in n:
				info.update(data)
				return

		data = ask_who_is(a)

		if failed(data):
			data = { 'ERROR': f'query for {a} failed: {data["ERROR"]}' }
		else:
			nets = data['NET']
			ip_nets.extend(( (n, data) for n in nets ))
			data['NET'] = ','.join(map(str, nets))

		info.update(data)

	# return from ip_info_fetcher()
	return get

# ip address info function
whois = ip_info_fetcher()

# local interfaces data loader
def local_ip_net():
	cmd = [ 'ip', '-j', '-p', 'address', 'show', 'up' ]

	try:
		with popen(cmd, stdout = PIPE, text = True) as src:
			s = read_json(src.stdout)

			src.communicate()

			if src.returncode != 0:
				exit(src.returncode)
	except JSONDecodeError as err:
		exit('invalid JSON in local interface data: ' + err.msg)
	except Exception as err:
		exit('cannot read local interface data: ' + str(err))

	net = lambda x: ip_interface(f'{x["local"]}/{x["prefixlen"]}').network
	pair = lambda x: (x['ifname'], tuple(map(net, x['addr_info'])))

	ints = dict(( pair(i) for i in s if i.get('addr_info') ))

	def get(addr, itf):
		try:
			for n in ints[itf]:
				if addr in n:
					return str(n)
		except KeyError:
			pass

	return get

get_local_ip_net = local_ip_net()

# ip address scope
def ip_scope(addr):
	s = frozenset(choose(
		('multicast', 'private', 'global', 'unspecified', 'reserved', 'loopback', 'link_local'),
		(addr.is_multicast, addr.is_private, addr.is_global, addr.is_unspecified, addr.is_reserved, addr.is_loopback, addr.is_link_local)
	))

	return s if s else frozenset(('unknown',))

# ip address analyser
def get_addr_info(addr, itf):
	scope = ip_scope(addr)
	info = { 'IP': addr.compressed, 'SCOPE': ','.join(scope) }

	# host name
	if ('private' in scope or 'global' in scope) and 'multicast' not in scope:
		try:
			info['HOST'] = gethostbyaddr(addr.compressed)[0]
		except OSError as err:
			if err.errno != 1:
				info['ERROR'] = f'error: host name query for {addr.compressed} failed: {err}'
				return info

	# other info
	if itf:
		set_value(info, 'NET', get_local_ip_net(addr, itf))
	elif 'global' in scope:
		whois(addr, info)

	return info


# construct iterator over journalctl output
def ufw_action_iterator(file_name = None):
	# address cache: { interface -> { addr.compressed -> info } }
	# because a computer can have several network interfaces with the same ip address,
	# see: https://serverfault.com/questions/705919/the-same-ip-on-multiple-interfaces
	addr_cache = {}

	# address info composer
	def addr_info(rec, ip_key, port_key, itf_key):
		try:
			addr, itf = ip_address(rec[ip_key]), rec.pop(itf_key) or ''
		except KeyError as err:
			exit(f'key {err} is missing from journalctl output')

		try:
			info = dict(addr_cache[itf][addr.compressed])
		except KeyError:
			info = get_addr_info(addr, itf)
			addr_cache.setdefault(itf, {})[addr.compressed] = info
			info = dict(info)

		try:
			port = int(rec.pop(port_key))
		except (KeyError, ValueError):
			pass
		else:
			info['PORT'] = port

		set_value(info, 'IF', itf)
		rec[ip_key] = info

	wanted = regex(r'^(?:IN|OUT|SRC|DST|PROTO|SPT|DPT)=').match

	def make_rec(m):
		act, ts, s = m.group(1), m.string[:m.start()], m.string[m.end():]
		rec = dict(( x.split('=', 1) for x in s.split() if wanted(x) ))

		rec.update(TS = ts, ACTION = act)

		addr_info(rec, 'DST', 'DPT', 'IN')
		addr_info(rec, 'SRC', 'SPT', 'OUT')

		return rec

	match_sep = regex(r'\s+kernel:\s+\[UFW\s+([A-Z]+)\]').search

	try:
		if file_name:	# for debugging only
			with open(file_name) as f:
				yield from map(make_rec, filter(None, map(match_sep, f)))
		else:
			cmd = ['journalctl',
						'--no-pager',
						'--no-hostname',
						'-o', 'short-iso-precise',
						'-b',
						'-q',
						'-g', r'\[UFW [A-Z]+\]']

			with popen(cmd, stdout = PIPE, text = True) as src:
				yield from map(make_rec, filter(None, map(match_sep, src.stdout)))

				src.communicate()

				if src.returncode != 0:
					exit(src.returncode)
	except OSError as err:
		exit(err)

# JSON output
def print_json(actions):
	from json import JSONEncoder

	encode = JSONEncoder(ensure_ascii = False).encode

	print('[', encode(next(actions)))

	for act in actions:
		print(',', encode(act))

	print(']')

# plain text output
def print_text(actions):
	def printer(pad, *keys):
		max_len = max(map(len, keys))

		def prn(data):
			if failed(data):
				print(f'{pad}ERROR: {data["ERROR"]}')
			else:
				for key in keys:
					print(f'{pad}{key}: {" " * (max_len - len(key))}{data.get(key, "n/a")}')

		return prn

	print_action = printer('', 'TS', 'ACTION', 'PROTO')
	print_ip = printer('  ', 'SCOPE', 'IF', 'IP', 'PORT', 'HOST', 'NET', 'NAME', 'DESCR', 'COUNTRY')

	for act in actions:
		print_action(act)
		print('SRC:')
		print_ip(act['SRC'])
		print('DEST:')
		print_ip(act['DST'])
		print()

# test
#for rec in ufw_action_iterator('test-data'):
	#print('->', rec)
#exit(0)

# script entry point
if len(argv) == 2 and argv[1] in ('-j', '--json'):
	print_json(ufw_action_iterator())
elif len(argv) == 1:
	print_text(ufw_action_iterator())
else:
	exit(f'Usage: {argv[0]} [-j,--json]\nShow ufw actions since boot, with ip address information from ARIN database.')
