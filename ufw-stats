#!/usr/bin/env python3

from sys import exit
from re import compile as regex
from subprocess import PIPE, Popen as popen
from urllib.request import urlopen
from ssl import create_default_context as ssl_default_context
from json import load as read_json, JSONDecodeError
from ipaddress import ip_address, summarize_address_range as ip_range
from socket import gethostbyaddr

fmt_os_error = lambda err: str(err).lstrip('<').rstrip('>')

def ip_info_fetcher(url_prefix = 'https://rdap.arin.net/registry/ip/'):
	ctx = ssl_default_context()	# SSL context

	# prevent the "[SSL: DH_KEY_TOO_SMALL] dh key too small" error
	ctx.set_ciphers('ALL@SECLEVEL=1')	# or 'DEFAULT@SECLEVEL=1'

	def ask_who_is(addr):
		try:
			with urlopen(url_prefix + addr, context = ctx, timeout = 5) as resp:
				s = read_json(resp)
		except JSONDecodeError as err:
			return { 'ERROR': 'parsing JSON response: ' + err.msg }
		except OSError as err:
			return { 'ERROR': 'fetching JSON response: ' + fmt_os_error(err) }

		try:
			res = {
				'NAME': s['name'],
				'NET': tuple(ip_range(ip_address(s['startAddress']), ip_address(s['endAddress'])))
			}
		except KeyError as err:
			try:
				return { 'ERROR': str(s['errorCode']) + ': ' + s['title'] }
			except KeyError:
				return { 'ERROR': f'parameter {err} is missing from JSON response' }

		try:
			res['COUNTRY'] = s['country'].upper()
		except KeyError:
			pass

		try:
			res['DESCR'] = s['remarks'][0]['description'][0]
		except (KeyError, IndexError):
			pass

		try:
			res['HOST'] = gethostbyaddr(addr)[0]
		except OSError as err:
			if err.errno != 1:
				return { 'ERROR': 'getting host name: ' + fmt_os_error(err) }

		return res

	# ip address info cache
	ip_cache = {}	# { str(ip) -> info }

	# list of networks
	ip_nets = []	# of (IPNetwork, info)

	def who_is(addr):
		a = str(addr)

		try:
			return ip_cache[a]
		except KeyError:
			pass

		for n, info in ip_nets:
			if addr in n:
				ip_cache[a] = info
				return info

		info = ask_who_is(a)
		nets = info.get('NET')

		if nets:
			info['NET'] = ','.join((str(n) for n in nets))
			ip_nets.extend(((n, info) for n in nets))

		ip_cache[a] = info

		return info

	# return from ip_info_fetcher()
	return who_is

# fetcher instance
whois = ip_info_fetcher()

def get_addr_info(addr):
	if addr.is_multicast:
		return { 'TYPE': 'multicast' }
	if addr.is_private:
		try:
			return { 'TYPE': 'private', 'HOST': gethostbyaddr(str(addr))[0] }
		except OSError as err:
			return { 'TYPE': 'private' } if err.errno == 1 else { 'ERROR': fmt_os_error(err) }
	if addr.is_unspecified:
		return { 'TYPE': 'unspecified' }
	if addr.is_reserved:
		return { 'TYPE': 'reserved' }
	if addr.is_loopback:
		return { 'TYPE': 'loopback' }
	if addr.is_link_local:
		return { 'TYPE': 'link_local' }
	if not addr.is_global:
		return { 'TYPE': 'unknown' }

	info = whois(addr)

	if 'ERROR' not in info:
		info['TYPE'] = 'global'

	return info


#for addr in ('149.154.167.92', '2a00:1450:4009:80d::200e', '149.154.167.91', '127.0.0.1'):
	#print(addr, '->', get_addr_info(ip_address(addr)))

#from sys import exit
#exit(0)


def records():
	cmd = ['journalctl',
				'--no-pager',
				'--no-hostname',
				'-o', 'short-iso-precise',
				'-b',
				'-q',
				'-g', r'\[UFW [A-Z]+\]']

	def addr_info(rec, ip_key, port_key):
		try:
			addr = ip_address(rec[ip_key])
		except KeyError:
			return

		info = get_addr_info(addr)
		info['IP'] = addr

		try:
			info['PORT'] = int(rec[port_key])
			del rec[port_key]
		except KeyError:
			pass
		except ValueError:
			del rec[port_key]

		rec[ip_key] = info

	wanted = regex(r'^(?:IN|OUT|SRC|DST|PROTO|SPT|DPT)=').match

	def make_rec(m):
		act, ts, s = m.group(1), m.string[:m.start()], m.string[m.end():]
		rec = dict(( x.split('=', 1) for x in s.split() if wanted(x) ))

		rec.update(TS = ts, ACTION = act)
		addr_info(rec, 'DST', 'DPT')
		addr_info(rec, 'SRC', 'SPT')

		return rec

	match_sep = regex(r'\s+kernel:\s+\[UFW\s+([A-Z]+)\]').search

	try:
		with popen(cmd, stdout = PIPE, text = True) as src:
			yield from map(make_rec, filter(None, map(match_sep, src.stdout)))

			src.communicate()

			if src.returncode != 0:
				exit(src.returncode)

	except Exception as err:
		exit(err)




for rec in records():
	print(rec)







	#with popen(['curl', '-sf', '--ciphers', 'DEFAULT@SECLEVEL=1', url], stdout = PIPE, text = True) as cmd:
		#for s in cmd.stdout:
			#print(s.strip())



